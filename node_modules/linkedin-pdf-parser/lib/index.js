'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _pdf2json = require('pdf2json');

var _pdf2json2 = _interopRequireDefault(_pdf2json);

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _momentTimezone = require('moment-timezone');

var _momentTimezone2 = _interopRequireDefault(_momentTimezone);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var JOB_SEPERATOR = '  at  ';
var DATE_SEPERATOR = '  -  ';

var getHLines = _ramda2.default.compose(_ramda2.default.map(_ramda2.default.prop('y')), _ramda2.default.flatten, _ramda2.default.prop('HLines'));

var getTexts = _ramda2.default.compose(_ramda2.default.slice(2, Infinity), // Remove 'Page [number]'
_ramda2.default.prop('Texts'));

var getRawTexts = _ramda2.default.compose(_ramda2.default.map(_ramda2.default.evolve({
  T: _ramda2.default.compose(_ramda2.default.trim, decodeURIComponent)
})), _ramda2.default.flatten, _ramda2.default.map(_ramda2.default.prop('R')));

var parseDate = function parseDate(str) {
  var date = new Date(str);
  if (!(0, _momentTimezone2.default)(date).isValid()) return undefined;
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
  return date;
};

// assumes that position lines have already been joined into single lines (i.e.
// that they do no span multiple lines)
var isPosition = function isPosition(str) {
  return str.indexOf(JOB_SEPERATOR) !== -1;
};

// See https://github.com/modesty/pdf2json#text-style-data-without-style-dictionary
var isBold = function isBold(text) {
  return text.TS[2] === 1;
};

var getPositions = function getPositions(rawTexts) {

  // join lines that are in bold as job only "title at company" lines are bold
  var texts = [rawTexts[0].T];
  for (var i = 1; i < rawTexts.length; i++) {
    var lastText = rawTexts[i - 1];
    var currText = rawTexts[i];
    if (isBold(lastText) && isBold(currText)) {
      texts[texts.length - 1] = texts[texts.length - 1] + ' ' + currText.T;
    } else texts.push(currText.T);
  }

  var positions = [];
  for (var _i = 0; _i < texts.length; _i++) {
    var text = texts[_i];
    if (isPosition(text)) {
      var _R$map = _ramda2.default.map(_ramda2.default.trim, text.split(JOB_SEPERATOR)),
          _R$map2 = _slicedToArray(_R$map, 2),
          title = _R$map2[0],
          company = _R$map2[1];

      var _R$map3 = _ramda2.default.map(parseDate, texts[_i + 1].split(DATE_SEPERATOR)),
          _R$map4 = _slicedToArray(_R$map3, 2),
          startDate = _R$map4[0],
          endDate = _R$map4[1];

      positions.push({
        title: title,
        company: company,
        startDate: startDate,
        endDate: endDate,
        summary: []
      });
      _i = _i + 2; // jump past date and span
    } else {
      positions[positions.length - 1].summary.push(text);
    }
  }

  // Join together summary
  positions = _ramda2.default.map(function (pos) {
    return Object.assign({}, pos, { summary: pos.summary.join('\n') });
  })(positions);

  return positions;
};

var parsePages = function parsePages(pages) {
  var hlinesPaged = _ramda2.default.map(getHLines, pages);
  var textsPaged = _ramda2.default.map(getTexts, pages);
  var groups = [];

  // Groups texts according to hlines

  var _loop = function _loop(i) {
    var hlines = hlinesPaged[i];
    var texts = textsPaged[i];

    groups.push(_ramda2.default.groupBy(function (text) {
      return _ramda2.default.findIndex(function (hline) {
        return text.y < hline;
      })(hlines);
    }, texts));
  };

  for (var i = 0; i < pages.length; i++) {
    _loop(i);
  }

  // Combine groups below last hline on a page and above first hline on next page
  for (var _i2 = 1; _i2 < groups.length; _i2++) {
    if (!groups[_i2 - 1]['-1'] || !(groups[_i2]['0'] || groups[_i2]['-1'])) continue;
    if (groups[_i2]['0']) {
      groups[_i2]['0'] = _ramda2.default.concat(groups[_i2 - 1]['-1'], groups[_i2]['0']);
    } else {
      groups[_i2]['-1'] = _ramda2.default.concat(groups[_i2 - 1]['-1'], groups[_i2]['-1']);
    }
    delete groups[_i2 - 1]['-1'];
  }

  // Unnest pages and collect groups into a single array of groups,
  // then get the texts within each group
  groups = _ramda2.default.compose(_ramda2.default.map(getRawTexts), _ramda2.default.unnest, _ramda2.default.map(_ramda2.default.valuesIn))(groups);

  // Get the sections we care about
  var sections = {};
  for (var _i3 = 0; _i3 < groups.length; _i3++) {
    var _groups$_i = _toArray(groups[_i3]),
        head = _groups$_i[0],
        tail = _groups$_i.slice(1);

    switch (head.T) {
      case 'Summary':
        sections.summary = _ramda2.default.map(_ramda2.default.prop('T'), tail).join('\n');
        break;
      case 'Experience':
        sections.positions = getPositions(tail);
        break;
      default:
        break;
    }
  }

  return sections;
};

var parse = function parse(pdfBuffer) {
  return new Promise(function (resolve, reject) {
    var pdfParser = new _pdf2json2.default();
    pdfParser.on('pdfParser_dataReady', function (pdfData) {
      try {
        var data = parsePages(pdfData.formImage.Pages);
        resolve(data);
      } catch (err) {
        reject(err);
      }
    });
    pdfParser.on('pdfParser_dataError', function (errData) {
      return reject(errData);
    });
    pdfParser.parseBuffer(pdfBuffer);
  });
};

exports.default = parse;